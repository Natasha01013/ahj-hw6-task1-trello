# CI Tests
[![Build status](https://ci.appveyor.com/api/projects/status/8v4s59ita7502f9f?svg=true)](https://ci.appveyor.com/project/Natasha01013/ahj-hw6-task1-trello)  

# Домашнее задание к занятию "6. Работа с файлами, DnD"  
## Задача 1. Trello  

Правила сдачи задания:  

1. **Важно**: в рамках этого ДЗ нужно использовать yarn (поэтому файла `package-lock.json` в репозитории быть не должно)  
2. Всё должно собираться через Webpack (включая картинки и стили) и выкладываться на Github Pages через Appveyor  
3. В README.md должен быть размещён бейджик сборки и ссылка на Github Pages  
4. В качестве результата присылайте проверяющему ссылки на ваши GitHub-проекты  
5. Авто-тесты писать не требуется  


### Легенда  
Вы делаете внутрикорпоративную систему управления задачами и вашему руководству очень нравится подход, который используется в [Trello](https://trello.com/):  
![image](https://github.com/netology-code/ahj-homeworks/blob/AHJ-50/dnd/pic/trello.png)  

### Описание  
Фактически у вас есть доска, состоящая из колонок, в каждой колонке может быть несколько карточек.  

Для упрощения сделаем следующие допущения:  

1. Кол-во колонок фиксировано и равно 3  
2. Новые колонки добавлять нельзя, удалять имеющиеся тоже  
3. Перемещать колонки тоже нельзя  

Что же можно:  

1. Добавлять карточки с помощью кнопки 'Add another card'. Вот так это выглядит:  

![image](https://github.com/netology-code/ahj-homeworks/blob/AHJ-50/dnd/pic/trello-2.png)  
![image](https://github.com/netology-code/ahj-homeworks/blob/AHJ-50/dnd/pic/trello-3.png)  
Пустую карточку добавить нельзя. Поле ввода необходимо очищать после добавления карточки.  

2. Удалять карточки - при наведении на карточку появляется иконка крестик ("\E951"), которая и удаляет карточку (обратите внимание в оригинальном Trello такой операции нет, есть только архивация, но мы для упрощения её ввели). Когда карточка не активна, иконка крестика не видна:  

![image](https://github.com/netology-code/ahj-homeworks/blob/AHJ-50/dnd/pic/trello-4.png)   
 
3. Перемещать карточки как внутри колонки, так и между колонками.  

**Процесс перемещения**  
1. Внешний вид до переноса (карточка находится на своём месте):  

![image](https://github.com/netology-code/ahj-homeworks/blob/AHJ-50/dnd/pic/trello-5.png)  

2. Внешний вид в момент переноса (карточка удаляется из своего начального положения):  

![image](https://github.com/netology-code/ahj-homeworks/blob/AHJ-50/dnd/pic/trello-6.png)  

**Обратите внимание на следующие нюансы**:  

1. Внешний вид курсора ('grabbing')  
2. Курсор по отношению к карточке остаётся там, где изначально схватили - не привязывается ни к левому краю, ни к центру, а там, где схватили карточку, т.е. можно схватить за нижний левый угол:  

![image](https://github.com/netology-code/ahj-homeworks/blob/AHJ-50/dnd/pic/trello-7.png)  

3. При наведении на другие позиции под карточку выделяется место по высоте равное размеру самой карточке, при этом будет карточка ставится "до" или "после" элемента определяется исключительно позицией курсора:  

![image](https://github.com/netology-code/ahj-homeworks/blob/AHJ-50/dnd/pic/trello-8.png)  

4.	Перетаскивание осуществляется с помощью mousedown, mouseup, mousemove. Mousedown происходит в момент нажатия на кнопку мыши. Обработчик получает информацию на каком элементе произошло нажатие. Далее проверяется, если нажатие произошло на кнопку удаления, то код прекращает работу. Если нажатие было на пустую область страницы, то код тоже завершает свое действие.  
5.	Перетаскиваемый элемент необходимо запомнить и сохранить в переменной, которая дальше будет использоваться для перемещения карточки.  
6.	Карточка перемещается с помощью абсолютного позиционирования. Ширину надо установить явным образом, чтобы она не менялась при перетаскивании.   
7.	Чтобы запомнить положение мыши необходимо: получить координаты мыши, получить текущие координаты элемента, вычислить разницу между ними, сохранить разницу.  
8.	Пустой элемент (фантомный элемент) нужен, чтобы показать откуда карточка была взята и куда ее надо вернуть. Добавляем классы для визуального отображения. Карточка может быть полупрозрачной, когда мы ее тянем.  
9.	Mousemove возникает, когда мышь двигается после нажатия. Сначала проверяется есть ли карточка, которую мы перетаскиваем. Если перетаскиваемой карточки нет, то код прекращается.   
10.	Надо определить над каким элементом находится курсор мыши. Если он не находится на html-элементом, то код прекращается. Используйте e.target. Дальше определяется над какой карточкой находится курсор.   
11.	Карточка, которую мы перетаскиваем постоянно перемещается за курсором. Это происходит путем обновления ее координат left, top на основе текущего положения мыши с учетом ранее запомненного смещения.  
12.	Когда курсор находится над контейнером для карточек, делается проверка куда именно можно вставить фантом. Если поле сброса пустое, то фантом просто добавляется в контейнер. Если там уже есть карточки, то делается проверка, находится ли курсор ниже карточке, то вставляется в конец контейнера, а если выше мыши, то в начало. Если фантом стоит в нужном месте, то вставка не нужна. Фантом сначала удаляем из старого места, потом вставляем в новое в зависимости от того, где находится курсор.   
13.	Mouseup – здесь надо отписаться от всех событий, которые были активны в момент перетаскивания и удалить все стили с временно присвоенных карточек. И удалить фантомный элемент и обнулить все временные переменные.   

**Дополнительные требования:**  

1. Храните всё состояние в LocalStorage так, чтобы после обновления страницы внесённые изменения сохранялись  
2. Постоение DOM-дерева производите на базе состояния, хранящегося в LocalStorage  

**В целях упрощения сделайте только:**  

1. Возможность хранить текст (картинки, списки, цветовое оформление элементов не нужно)  
2. Перемещение самой карточки (поворот делать не нужно)  
3. Можете также не обрабатывать ситуацию, связанную с выносом элемента за пределы доски  